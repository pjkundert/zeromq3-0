zmq_log(3)
===========


NAME
----
zmq_log - log a formatted message to the shared sys://log socket


SYNOPSIS
--------
*int zmq_log (void '*context', cost char '*format', '...');*


DESCRIPTION
-----------
The _zmq_log()_ function shall format and send a message created from
the buffer referenced by the 'format' (and all following) arguments.
The 'format' and remaining arguments are processed according to
snprintf[3].

NOTE: A successful invocation of _zmq_log()_ does not indicate that
the message has been transmitted to the network, only that it has been
queued on the 'socket' and 0MQ has assumed responsibility for the
message.  If no other ZMQ_SUB sockets are connected to "sys://log", or
have not subscribed using xsetsockopt/ZMQ_SUBSCRIBE, then the message
will be discarded.

If desired, you may use zmq_log_subs[3] to detect if any listeners
have subscribed to your message before producing it.  This is
important if your message is costly to produce.

An arbitrary limit of 1024 characters is enforced on the formatted
output message.


ERRORS
------
*EFAULT*::
The provided 'context' is invalid.
*ETERM*::
The 0MQ 'context' was terminated.


EXAMPLE
-------
.Logging a formatted message, and receiving log messages
----
/* 
 * Here is a hypothetical logging scenario.  The log messages
 * are formatted with 1-character logging level, followed by an
 * "area of interest" label.  
 */
context = zmq_init (5);
const char *format = "W daemon Hello %s!";
if (zmq_log_subs (format, strlen(format))) {
    /* ... create expensive log message here? ... */
    rc = zmq_log (context, format, "World");
    assert (rc == 0);
}


/*
 * Connect to the logging publisher, and  subscribe to
 * all Errors (E), and Warnings (W) from the "daemon" subsystem.
 */
context = zmq_init (5);
void *logs = zmq_socket (context, ZMQ_SUB);
assert (loggin != NULL)
int rc = zmq_connect (loging, "sys://log");
assert (rc == 0);
rc = zmq_setsockopt (logging, ZMQ_SUBSCRIBE, "W daemon", 8);
assert (rc == 0);
rc = zmq_setsockopt (logging, ZMQ_SUBSCRIBE, "E", 1);
assert (rc == 0);

/* Create an empty 0MQ message */
zmq_msg_t msg;
rc = zmq_msg_init (&msg);
assert (rc == 0);

/* Receive and print (fixed length) logging messages 'til an error occurs */
while ((rc = zmq_recvmsg (logging, &msg)) != -1) {
      printf ("%.*s", (int)zmq_msg_size(&msg), (const char *)zmq_msg_data(&msg))
}
----


SEE ALSO
--------
snprintf[3]
linkzmq:zmq_init[3]
linkzmq:zmq_log_subs[3]
linkzmq:zmq[7]

AUTHORS
-------
This man page was written by Perry Kundert <perry@kundert.ca>.
